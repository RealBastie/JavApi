/*
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  
 */
using System;
using System.Text;
using java = biz.ritter.javapi;

namespace biz.ritter.javapi.math
{

    /**
     * Immutable objects describing settings such as rounding mode and digit
     * precision for the numerical operations provided by class {@link BigDecimal}.
     */
    [Serializable]
    public sealed class MathContext : java.io.Serializable {

        /**
         * A {@code MathContext} which corresponds to the IEEE 754r quadruple
         * decimal precision format: 34 digit precision and
         * {@link RoundingMode#HALF_EVEN} rounding.
         */
        public static readonly MathContext DECIMAL128 = new MathContext(34,
                RoundingMode.HALF_EVEN);

        /**
         * A {@code MathContext} which corresponds to the IEEE 754r single decimal
         * precision format: 7 digit precision and {@link RoundingMode#HALF_EVEN}
         * rounding.
         */
        public static readonly MathContext DECIMAL32 = new MathContext(7,
                RoundingMode.HALF_EVEN);

        /**
         * A {@code MathContext} which corresponds to the IEEE 754r double decimal
         * precision format: 16 digit precision and {@link RoundingMode#HALF_EVEN}
         * rounding.
         */
        public static readonly MathContext DECIMAL64 = new MathContext(16,
                RoundingMode.HALF_EVEN);

        /**
         * A {@code MathContext} for unlimited precision with
         * {@link RoundingMode#HALF_UP} rounding.
         */
        public static readonly MathContext UNLIMITED = new MathContext(0,
                RoundingMode.HALF_UP);

        /** This is the serialVersionUID used by the sun implementation */
        private static readonly long serialVersionUID = 5579720004786848255L;

        /**
         * The number of digits to be used for an operation; results are rounded to
         * this precision.
         */
        private int precision;

        /**
         * A {@code RoundingMode} object which specifies the algorithm to be used
         * for rounding.
         */
        private RoundingMode roundingMode;

        /**
         * An array of {@code char} containing: {@code
         * 'p','r','e','c','i','s','i','o','n','='}. It's used to improve the
         * methods related to {@code String} conversion.
         *
         * @see #MathContext(String)
         * @see #toString()
         */
        private readonly static char[] chPrecision = { 'p', 'r', 'e', 'c', 'i', 's',
                'i', 'o', 'n', '=' };

        /**
         * An array of {@code char} containing: {@code
         * 'r','o','u','n','d','i','n','g','M','o','d','e','='}. It's used to
         * improve the methods related to {@code String} conversion.
         *
         * @see #MathContext(String)
         * @see #toString()
         */
        private readonly static char[] chRoundingMode = { 'r', 'o', 'u', 'n', 'd',
                'i', 'n', 'g', 'M', 'o', 'd', 'e', '=' };

        /**
         * Constructs a new {@code MathContext} with the specified precision and
         * with the rounding mode {@link RoundingMode#HALF_UP HALF_UP}. If the
         * precision passed is zero, then this implies that the computations have to
         * be performed exact, the rounding mode in this case is irrelevant.
         *
         * @param precision
         *            the precision for the new {@code MathContext}.
         * @throws IllegalArgumentException
         *             if {@code precision < 0}.
         */
        public MathContext(int precision) :this(precision, RoundingMode.HALF_UP){
        }

        /**
         * Constructs a new {@code MathContext} with the specified precision and
         * with the specified rounding mode. If the precision passed is zero, then
         * this implies that the computations have to be performed exact, the
         * rounding mode in this case is irrelevant.
         *
         * @param precision
         *            the precision for the new {@code MathContext}.
         * @param roundingMode
         *            the rounding mode for the new {@code MathContext}.
         * @throws IllegalArgumentException
         *             if {@code precision < 0}.
         * @throws NullPointerException
         *             if {@code roundingMode} is {@code null}.
         */
        public MathContext(int precision, RoundingMode roundingMode) {
            if (precision < 0) {
                // math.0C=Digits < 0
                throw new java.lang.IllegalArgumentException("Digits < 0"); //$NON-NLS-1$
            }
            if (roundingMode == null) {
                // math.0D=null RoundingMode
                throw new java.lang.NullPointerException("null RoundingMode"); //$NON-NLS-1$
            }
            this.precision = precision;
            this.roundingMode = roundingMode;
        }

        /**
         * Constructs a new {@code MathContext} from a string. The string has to
         * specify the precision and the rounding mode to be used and has to follow
         * the following syntax: "precision=&lt;precision&gt; roundingMode=&lt;roundingMode&gt;"
         * This is the same form as the one returned by the {@link #toString}
         * method.
         *
         * @param val
         *            a string describing the precision and rounding mode for the
         *            new {@code MathContext}.
         * @throws IllegalArgumentException
         *             if the string is not in the correct format or if the
         *             precision specified is < 0.
         */
        public MathContext(String val) {
            char[] charVal = val.toCharArray();
            int i; // Index of charVal
            int j; // Index of chRoundingMode
            int digit; // It will contain the digit parsed

            if ((charVal.Length < 27) || (charVal.Length > 45)) {
                // math.0E=bad string format
                throw new java.lang.IllegalArgumentException("bad string format"); //$NON-NLS-1$
            }
            // Parsing "precision=" String
            for (i = 0; (i < chPrecision.Length) && (charVal[i] == chPrecision[i]); i++) {
                ;
            }

            if (i < chPrecision.Length) {
                // math.0E=bad string format
                throw new java.lang.IllegalArgumentException("bad string format"); //$NON-NLS-1$
            }
            // Parsing the value for "precision="...
            digit = java.lang.Character.digit(charVal[i], 10);
            if (digit == -1) {
                // math.0E=bad string format
                throw new java.lang.IllegalArgumentException("bad string format"); //$NON-NLS-1$
            }
            this.precision = this.precision * 10 + digit;
            i++;

            do {
                digit = java.lang.Character.digit(charVal[i], 10);
                if (digit == -1) {
                    if (charVal[i] == ' ') {
                        // It parsed all the digits
                        i++;
                        break;
                    }
                    // It isn't  a valid digit, and isn't a white space
                    // math.0E=bad string format
                    throw new java.lang.IllegalArgumentException("bad string format"); //$NON-NLS-1$
                }
                // Accumulating the value parsed
                this.precision = this.precision * 10 + digit;
                if (this.precision < 0) {
                    // math.0E=bad string format
                    throw new java.lang.IllegalArgumentException("bad string format"); //$NON-NLS-1$
                }
                i++;
            } while (true);
            // Parsing "roundingMode="
            for (j = 0; (j < chRoundingMode.Length)
                    && (charVal[i] == chRoundingMode[j]); i++, j++) {
                ;
            }

            if (j < chRoundingMode.Length) {
                // math.0E=bad string format
                throw new java.lang.IllegalArgumentException("bad string format"); //$NON-NLS-1$
            }
            // Parsing the value for "roundingMode"...
            this.roundingMode = RoundingMode.valueOf(java.lang.StringJ.valueOf(charVal, i,charVal.Length - i).ToString());
        }

        /* Public Methods */

        /**
         * Returns the precision. The precision is the number of digits used for an
         * operation. Results are rounded to this precision. The precision is
         * guaranteed to be non negative. If the precision is zero, then the
         * computations have to be performed exact, results are not rounded in this
         * case.
         *
         * @return the precision.
         */
        public int getPrecision() {
            return precision;
        }

        /**
         * Returns the rounding mode. The rounding mode is the strategy to be used
         * to round results.
         * <p>
         * The rounding mode is one of
         * {@link RoundingMode#UP},
         * {@link RoundingMode#DOWN},
         * {@link RoundingMode#CEILING},
         * {@link RoundingMode#FLOOR},
         * {@link RoundingMode#HALF_UP},
         * {@link RoundingMode#HALF_DOWN},
         * {@link RoundingMode#HALF_EVEN}, or
         * {@link RoundingMode#UNNECESSARY}.
         *
         * @return the rounding mode.
         */
        public RoundingMode getRoundingMode() {
            return roundingMode;
        }

        /**
         * Returns true if x is a {@code MathContext} with the same precision
         * setting and the same rounding mode as this {@code MathContext} instance.
         *
         * @param x
         *            object to be compared.
         * @return {@code true} if this {@code MathContext} instance is equal to the
         *         {@code x} argument; {@code false} otherwise.
         */
        
        public override bool Equals(Object x) {
            return ((x is MathContext)
                    && (((MathContext) x).getPrecision() == precision) && (((MathContext) x)
                    .getRoundingMode() == roundingMode));
        }

        /**
         * Returns the hash code for this {@code MathContext} instance.
         *
         * @return the hash code for this {@code MathContext}.
         */
        
        public override int GetHashCode() {
            // Make place for the necessary bits to represent 8 rounding modes
            return ((precision << 3) | roundingMode.ordinal());
        }

        /**
         * Returns the string representation for this {@code MathContext} instance.
         * The string has the form
         * {@code
         * "precision=&lt;precision&gt; roundingMode=&lt;roundingMode&gt;"
         * } where {@code &lt;precision&gt;} is an integer describing the number
         * of digits used for operations and {@code &lt;roundingMode&gt;} is the
         * string representation of the rounding mode.
         *
         * @return a string representation for this {@code MathContext} instance
         */
        
        public override String ToString() {
            StringBuilder sb = new StringBuilder(45);

            sb.Append(chPrecision);
            sb.Append(precision);
            sb.Append(' ');
            sb.Append(chRoundingMode);
            sb.Append(roundingMode);
            return sb.ToString();
        }

        /**
         * Makes checks upon deserialization of a {@code MathContext} instance.
         * Checks whether {@code precision >= 0} and {@code roundingMode != null}
         *
         * @throws StreamCorruptedException
         *             if {@code precision < 0}
         * @throws StreamCorruptedException
         *             if {@code roundingMode == null}
         *
        private void readObject(ObjectInputStream s) throws IOException,
                ClassNotFoundException {
            s.defaultReadObject();
            if (precision < 0) {
                // math.0F=bad precision value
                throw new StreamCorruptedException(Messages.getString("math.0F")); //$NON-NLS-1$
            }
            if (roundingMode == null) {
                // math.10=null roundingMode
                throw new StreamCorruptedException(Messages.getString("math.10")); //$NON-NLS-1$
            }
        }*/

    }
}
